---

title: neos.transforms


keywords: fastai
sidebar: home_sidebar

summary: "Contains transforms to map from $[-\infty,\infty]$ to a bounded space $[a,b]$ and back."
description: "Contains transforms to map from $[-\infty,\infty]$ to a bounded space $[a,b]$ and back."
nb_path: "nbs/03_transforms.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/03_transforms.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This module implements two transforms, taken from the minuit optimizer:</p>
<p>{% raw %}
$$P_{\mathrm{inf}}=\arcsin \left(2 \frac{P_{\mathrm{bounded}}-a}{b-a}-1\right):~[a,b] \rightarrow [-\infty,\infty]$$
{% endraw %}</p>
<p>{% raw %}
$$P_{\mathrm{bounded}}=a+\frac{b-a}{2}\left(\sin P_{\mathrm{inf}}+1\right):~[-\infty,\infty]\rightarrow [a,b] $$
{% endraw %}</p>
<p>The purpose of these is to add stability to the maximum likelihood fits of the model parameters, which are currently done by gradient descent. This is done by allowing the minimization to occur on the real line, and then mapping the result to a value in a 'sensible' interval $[a,b]$ before evaluating the likelihood. You can imagine if this wasnt the case, it's possible that the likelihood may be evaluated with negative model parameters or very extreme values, potentially causing numeric instability in the likelihood or gradient evaluations.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="to_bounded_vec" class="doc_header"><code>to_bounded_vec</code><a href="https://github.com/phinate/neos/tree/talk/neos/transforms.py#L14" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>to_bounded_vec</code>(<strong><code>param</code></strong>, <strong><code>bounds</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="to_bounded" class="doc_header"><code>to_bounded</code><a href="https://github.com/phinate/neos/tree/talk/neos/transforms.py#L21" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>to_bounded</code>(<strong><code>param</code></strong>, <strong><code>bounds</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="to_inf_vec" class="doc_header"><code>to_inf_vec</code><a href="https://github.com/phinate/neos/tree/talk/neos/transforms.py#L27" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>to_inf_vec</code>(<strong><code>param</code></strong>, <strong><code>bounds</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="to_inf" class="doc_header"><code>to_inf</code><a href="https://github.com/phinate/neos/tree/talk/neos/transforms.py#L35" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>to_inf</code>(<strong><code>param</code></strong>, <strong><code>bounds</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Usage-+-tests:">Usage + tests:<a class="anchor-link" href="#Usage-+-tests:"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>  <span class="c1"># points</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]])</span>  <span class="c1"># bounds</span>

<span class="c1"># check if 1 is invariant if we transform to bounded space and back</span>
<span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">to_inf</span><span class="p">(</span><span class="n">to_bounded</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">cond</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">to_inf</span><span class="p">(</span><span class="n">to_bounded</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># check if [1,1] is invariant</span>
<span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">to_inf_vec</span><span class="p">(</span><span class="n">to_bounded_vec</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">b</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">cond</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">to_inf_vec</span><span class="p">(</span><span class="n">to_bounded_vec</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">bounds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">]])</span>

<span class="c1"># check that we map to inf space (i.e. -pi/2 to pi/2)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">to_inf</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min: </span><span class="si">{</span><span class="n">w</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2">, max: </span><span class="si">{</span><span class="n">w</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">, to inf:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>


<span class="c1"># check that we can map very large values to bounded space</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1e10</span><span class="p">,</span> <span class="mf">1e10</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">to_bounded</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min: </span><span class="si">{</span><span class="n">w</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">}</span><span class="s2">, max: </span><span class="si">{</span><span class="n">w</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">, to </span><span class="si">{</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()],),</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span>
<span class="p">),</span> <span class="s2">&quot;Large numbers are not mapped to the bounds of the bounded transform&quot;</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>min: 0.0, max: 10.0, to inf:
-1.5707963267948966 1.5707963267948966
min: -10000000000.0, max: 10000000000.0, to [ 0 10]:
2.5122629992990753e-06 9.999997487737
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Test-fitting-+-CLs-values-in-bounded-and-unbounded-parameter-spaces:">Test fitting + CLs values in bounded and unbounded parameter spaces:<a class="anchor-link" href="#Test-fitting-+-CLs-values-in-bounded-and-unbounded-parameter-spaces:"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">bounds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">]])</span>
<span class="c1"># define NLL functions in both parameter spaces</span>

<span class="kn">from</span> <span class="nn">neos</span> <span class="kn">import</span> <span class="n">models</span>


<span class="k">def</span> <span class="nf">make_nll_boundspace</span><span class="p">(</span><span class="n">hyperpars</span><span class="p">):</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">db</span> <span class="o">=</span> <span class="n">hyperpars</span>

    <span class="k">def</span> <span class="nf">nll_boundspace</span><span class="p">(</span><span class="n">pars</span><span class="p">):</span>
        <span class="n">truth_pars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">hepdata_like</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">s</span><span class="p">]),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">b</span><span class="p">]),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">db</span><span class="p">]))</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">expected_data</span><span class="p">(</span><span class="n">truth_pars</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">nll_boundspace</span>


<span class="k">def</span> <span class="nf">make_nll_infspace</span><span class="p">(</span><span class="n">hyperpars</span><span class="p">):</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">db</span> <span class="o">=</span> <span class="n">hyperpars</span>

    <span class="k">def</span> <span class="nf">nll_infspace</span><span class="p">(</span><span class="n">pars</span><span class="p">):</span>
        <span class="n">truth_pars</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">pars</span> <span class="o">=</span> <span class="n">to_bounded_vec</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">hepdata_like</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">s</span><span class="p">]),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">b</span><span class="p">]),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">db</span><span class="p">]))</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">expected_data</span><span class="p">(</span><span class="n">truth_pars</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">nll_infspace</span>


<span class="n">nll_boundspace</span> <span class="o">=</span> <span class="n">make_nll_boundspace</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="n">nll_infspace</span> <span class="o">=</span> <span class="n">make_nll_infspace</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

<span class="c1"># define a point and compute it in both spaces</span>
<span class="n">apoint_bnd</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">apoint_inf</span> <span class="o">=</span> <span class="n">to_inf_vec</span><span class="p">(</span><span class="n">apoint_bnd</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

<span class="c1"># check consistency in both spaces</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;check consistency in both spaces:&quot;</span><span class="p">)</span>
<span class="n">point_bound</span> <span class="o">=</span> <span class="n">nll_boundspace</span><span class="p">(</span><span class="n">apoint_bnd</span><span class="p">)</span>
<span class="n">point_inf</span> <span class="o">=</span> <span class="n">nll_infspace</span><span class="p">(</span><span class="n">apoint_inf</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
    <span class="n">point_bound</span><span class="p">,</span> <span class="n">point_inf</span>
<span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">point_bound</span><span class="si">}</span><span class="s2"> (bounded) should be close to </span><span class="si">{</span><span class="n">point_inf</span><span class="si">}</span><span class="s2"> (inf)&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;..good!&quot;</span><span class="p">)</span>
<span class="c1"># check gradients in bounded</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;gradients in bounded space:&quot;</span><span class="p">)</span>
<span class="n">dlb_dpb</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">nll_boundspace</span><span class="p">)(</span><span class="n">apoint_bnd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dlb_dpb</span><span class="p">)</span>

<span class="c1"># check gradients in inf</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;gradients in inf space:&quot;</span><span class="p">)</span>
<span class="n">dli_dinf</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">nll_infspace</span><span class="p">)(</span><span class="n">apoint_inf</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dli_dinf</span><span class="p">)</span>

<span class="c1"># check consistency of gradients</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;consistency? check with chain rule:&quot;</span><span class="p">)</span>
<span class="n">dli_dpi</span> <span class="o">=</span> <span class="n">dli_dinf</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">to_inf_vec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i</span><span class="p">])(</span><span class="n">apoint_bnd</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dli_dpi</span><span class="p">)</span>

<span class="c1"># li maps pi to bounded, then becomes lb, so grad should be the same</span>
<span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dli_dpi</span><span class="p">,</span> <span class="n">dlb_dpb</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;Chain rule... doesnt work? :o&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;all good here chief&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>check consistency in both spaces:
..good!
gradients in bounded space:
[ -0.96078431 -99.05962385]
gradients in inf space:
[  -2.09398087 -309.31357633]
consistency? check with chain rule:
[ -0.96078431 -99.05962385]
all good here chief
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

